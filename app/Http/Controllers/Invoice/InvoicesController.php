<?php

namespace App\Http\Controllers\Invoice;

use App\Driver;
use App\Http\Controllers\Controller;
use App\Models\Invoice\DeliveryTrip;
use App\Models\Invoice\DeliveryTripExpense;
use App\Models\Invoice\Invoice;
use App\Models\Invoice\InvoiceHistory;
use App\Models\Invoice\InvoicePayment;
use App\Models\Invoice\InvoiceStatus;
use App\Models\Invoice\Waybill;
use App\Models\Invoice\DispatchedInvoice;
use App\Models\Invoice\DispatchedWaybill;
use App\Models\Invoice\InvoiceItem;
use App\Models\Invoice\InvoiceItemBatch;
use App\Models\Invoice\WaybillItem;
use App\Models\Logistics\Vehicle;
use App\Models\Stock\ItemStock;
use App\Models\Stock\ItemStockSubBatch;
use App\Models\Warehouse\Warehouse;
use Illuminate\Http\Request;

class InvoicesController extends Controller
{
    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index(Request $request)
    {
        //
        $user = $this->getUser();
        $warehouse_id = $request->warehouse_id;
        $invoices = [];
        if (isset($request->status) && $request->status != '') {
            ////// query by status //////////////
            $status = $request->status;
            $invoices = Invoice::with(['warehouse', 'customer.user', 'customer.type', 'invoiceItems.item', 'histories' => function ($q) {
                $q->orderBy('id', 'DESC');
            }])->where(['warehouse_id' => $warehouse_id, 'status' => $status])->get();
        }
        if (isset($request->from, $request->to, $request->status) && $request->from != '' && $request->from != '' && $request->status != '') {
            $date_from = date('Y-m-d', strtotime($request->from)) . ' 00:00:00';
            $date_to = date('Y-m-d', strtotime($request->to)) . ' 23:59:59';
            $status = $request->status;
            $panel = $request->panel;
            $invoices = Invoice::with(['warehouse', 'customer.user', 'customer.type', 'invoiceItems.item', 'histories' => function ($q) {
                $q->orderBy('id', 'DESC');
            }])->where(['warehouse_id' => $warehouse_id, 'status' => $status])->where('created_at', '>=', $date_from)->where('created_at', '<=', $date_to)->get();
        }
        return response()->json(compact('invoices'));
    }
    public function unDeliveredInvoices(Request $request)
    {
        //
        $user = $this->getUser();
        $warehouse_id = $request->warehouse_id;
        // $invoices = Invoice::with(['invoiceItems', 'invoiceItems.item'])->where('warehouse_id', $warehouse_id)->where('status', '!=', 'delivered')->get();
        $invoices = Invoice::with(['invoiceItems' => function ($q) {
            $q->where('supply_status', '!=', 'Complete');
        }, 'invoiceItems.item', 'invoiceItems.batches.itemStockBatch.itemStock'])->where('warehouse_id', $warehouse_id)->where('status', '!=', 'delivered')->get();
        return response()->json(compact('invoices'));
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function assignInvoiceToWarehouse(Request $request, Invoice $invoice)
    {

        $warehouse_id = $request->warehouse_id;
        $warehouse = Warehouse::find($warehouse_id);
        $invoice->warehouse_id = $warehouse_id;
        $invoice->save();
        //log this activity
        $title = "Invoice Assigned";
        $description = "Assigned invoice ($invoice->invoice_number) to " . $warehouse->name;
        $this->logUserActivity($title, $description);
        return $this->show($invoice);
    }


    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
        $user = $this->getUser();
        $invoice_items = json_decode(json_encode($request->invoice_items));
        $invoice = new Invoice();
        $invoice->warehouse_id        = $request->warehouse_id;
        $invoice->customer_id         = $request->customer_id;
        $invoice->subtotal            = $request->subtotal;
        $invoice->discount            = $request->discount;
        $invoice->amount              = $request->amount;
        $invoice->invoice_number      = $request->invoice_number; // $this->nextInvoiceNo();
        $invoice->status              = $request->status;
        $invoice->notes              = $request->notes;
        $invoice->invoice_date        = date('Y-m-d H:i:s', strtotime($request->invoice_date));
        $invoice->save();
        $title = "New invoice generated";
        $description = "New $invoice->status invoice ($invoice->invoice_number) was generated by $user->name ($user->email)";
        //log this action to invoice history
        $this->createInvoiceHistory($invoice, $title, $description);
        //create items invoiceed for
        $this->createInvoiceItems($invoice, $invoice_items);
        //////update next invoice number/////
        // $this->incrementInvoiceNo();

        //log this activity
        $this->logUserActivity($title, $description);
        return $this->show($invoice);
    }

    private function createInvoiceHistory($invoice, $title, $description)
    {
        $invoice_history = new InvoiceHistory();
        $invoice_history->invoice_id = $invoice->id;
        $invoice_history->title = $title;
        $invoice_history->description = $description;
        $invoice_history->save();
    }

    private function createInvoiceItems($invoice, $invoice_items)
    {
        foreach ($invoice_items as $item) {
            $batches = $item->batches;
            $invoice_item = new InvoiceItem();
            $invoice_item->warehouse_id = $invoice->warehouse_id;
            $invoice_item->invoice_id = $invoice->id;
            $invoice_item->item_id = $item->item_id;
            $invoice_item->quantity = $item->quantity;
            $invoice_item->quantity_per_carton = $item->quantity_per_carton;
            $invoice_item->no_of_cartons = $item->no_of_cartons;
            $invoice_item->type = $item->type;
            $invoice_item->rate = $item->rate;
            $invoice_item->amount = $item->amount;
            $invoice_item->save();

            $this->createInvoiceItemBatches($invoice_item, $batches);
        }
    }
    private function createInvoiceItemBatches($invoice_item, $batches)
    {
        $quantity = $invoice_item->quantity;
        // If a specific batch was set when raising the invoice, we set it here
        if (!empty($batches)) {
            foreach ($batches as $batch) {
                $item_sub_batch = ItemStockSubBatch::find($batch);
                if ($quantity <= $item_sub_batch->balance) {
                    $invoice_item_batch = new InvoiceItemBatch();
                    $invoice_item_batch->invoice_id = $invoice_item->invoice_id;
                    $invoice_item_batch->invoice_item_id = $invoice_item->id;
                    $invoice_item_batch->item_stock_sub_batch_id = $batch;
                    $invoice_item_batch->quantity = $quantity;
                    $invoice_item_batch->save();
                    $item_sub_batch->reserved_for_supply += $quantity;
                    $item_sub_batch->save();
                    $quantity = 0;
                    break;
                } else {
                    $invoice_item_batch = new InvoiceItemBatch();
                    $invoice_item_batch->invoice_id = $invoice_item->invoice_id;
                    $invoice_item_batch->invoice_item_id = $invoice_item->id;
                    $invoice_item_batch->item_stock_sub_batch_id = $batch;
                    $invoice_item_batch->quantity = $item_sub_batch->balance;
                    $invoice_item_batch->save();
                    $item_sub_batch->reserved_for_supply += $item_sub_batch->balance;
                    $item_sub_batch->save();
                    $quantity -= $item_sub_batch->balance;
                }
            }
        } else {
            // If a specific batch was NOT set when raising the invoice, we make it automatic here using FIFO (First In First Out) principle
            $batches_of_items_in_stock = ItemStockSubBatch::where(['warehouse_id' => $invoice_item->invoice->warehouse_id, 'item_id' => $invoice_item->item_id])->where('balance', '>', '0')->orderBy('expiry_date')->get();

            foreach ($batches_of_items_in_stock as $item_sub_batch) {
                if ($quantity <= $item_sub_batch->balance) {
                    $invoice_item_batch = new InvoiceItemBatch();
                    $invoice_item_batch->invoice_id = $invoice_item->invoice_id;
                    $invoice_item_batch->invoice_item_id = $invoice_item->id;
                    $invoice_item_batch->item_stock_sub_batch_id = $item_sub_batch->id;
                    $invoice_item_batch->quantity = $quantity;
                    $invoice_item_batch->save();
                    $item_sub_batch->reserved_for_supply += $quantity;
                    $item_sub_batch->save();
                    $quantity = 0;
                    break;
                } else {
                    $invoice_item_batch = new InvoiceItemBatch();
                    $invoice_item_batch->invoice_id = $invoice_item->invoice_id;
                    $invoice_item_batch->invoice_item_id = $invoice_item->id;
                    $invoice_item_batch->item_stock_sub_batch_id = $item_sub_batch->id;
                    $invoice_item_batch->quantity = $item_sub_batch->balance;
                    $invoice_item_batch->save();
                    $item_sub_batch->reserved_for_supply += $item_sub_batch->balance;
                    $item_sub_batch->save();
                    $quantity -= $item_sub_batch->balance;
                }
            }
        }
    }

    /**
     * Display the specified resource.
     *
     * @param  \App\Models\Invoice\Invoice  $invoice
     * @return \Illuminate\Http\Response
     */
    public function show(Invoice $invoice)
    {
        //
        $invoice =  $invoice->with(['warehouse', 'customer.user', 'customer.type', 'invoiceItems.item', 'histories' => function ($q) {
            $q->orderBy('id', 'DESC');
        }])->find($invoice->id);
        return response()->json(compact('invoice'), 200);
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  \App\Models\Invoice\Invoice  $invoice
     * @return \Illuminate\Http\Response
     */
    public function changeInvoiceStaus(Request $request, Invoice $invoice)
    {
        //
        $user = $this->getUser();
        $status = $request->status;

        $invoice->status = $status;
        $invoice->save();
        $title = "Invoice status updated";
        $description = "Invoice ($invoice->invoice_number) status changed to " . strtoupper($invoice->status) . " by $user->name ($user->email)";
        //log this action to invoice history
        $this->createInvoiceHistory($invoice, $title, $description);

        // log this activity
        $this->logUserActivity($title, $description);
        return $this->show($invoice);
    }
    // this fetches all generated waybills
    public function waybills(Request $request)
    {
        $warehouse_id = $request->warehouse_id;
        $waybills = [];

        if (isset($request->status) && $request->status != '') {
            ////// query by status //////////////
            $status = $request->status;
            $waybills = Waybill::with(['dispatcher.vehicle.vehicleDrivers.driver.user', 'waybillItems.invoice.customer.user', 'waybillItems.item'])->where(['warehouse_id' => $warehouse_id, 'status' => $status])->get();
        }
        if (isset($request->from, $request->to, $request->status) && $request->from != '' && $request->from != '' && $request->status != '') {
            $date_from = date('Y-m-d', strtotime($request->from)) . ' 00:00:00';
            $date_to = date('Y-m-d', strtotime($request->to)) . ' 23:59:59';
            $status = $request->status;
            $panel = $request->panel;
            $invoices = Waybill::with(['dispatcher.vehicle.vehicleDrivers.driver.user', 'waybillItems.invoice.customer.user', 'waybillItems.item'])->where(['warehouse_id' => $warehouse_id, 'status' => $status])->where('created_at', '>=', $date_from)->where('created_at', '<=', $date_to)->get();
        }
        return response()->json(compact('waybills'));
    }
    // this fetches available drivers so that dispatching orders could be assigned to them
    public function fetchAvailableVehicles(Request $request)
    {
        //
        $warehouse_id = $request->warehouse_id;
        $vehicles = Vehicle::with('vehicleDrivers.driver.user')->where('warehouse_id', $warehouse_id)->get();
        $available_vehicles = [];
        foreach ($vehicles as $vehicle) {
            $dispatched_waybill = DispatchedWaybill::where('vehicle_id', $vehicle->id)->orderBy('id', 'Desc')->first();
            if ($dispatched_waybill) {
                if ($dispatched_waybill->waybill->status === 'delivered') {
                    $available_vehicles[] = $vehicle;
                }
            } else {
                $available_vehicles[] = $vehicle;
            }
        }
        return response()->json(compact('available_vehicles'), 200);
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function generateWaybill(Request $request)
    {
        //
        $user = $this->getUser();
        $invoice_ids = $request->invoice_ids;
        // $invoice = Invoice::find($request->invoice_id);
        $warehouse_id = $request->warehouse_id;
        $warehouse_id = $request->warehouse_id;
        $message = '';
        $invoice_items = json_decode(json_encode($request->invoice_items));

        // check if there are items in stock for this waybil to be generated
        foreach ($invoice_items as $invoice_item) {
            $item_in_stock_obj = new ItemStockSubBatch();
            $item_balance = $item_in_stock_obj->fetchBalanceOfItemsInStock($warehouse_id, $invoice_item->item_id);

            $quantity_for_supply = $invoice_item->quantity_for_supply;
            // check whether the balance is up to what was raised in the invoice
            if ($quantity_for_supply > $item_balance) {
                $message .= $invoice_item->item->name . ' remains only ' . $item_balance . ' ' . $invoice_item->item->package_type . ' in stock.<br>';
            }
        }

        if ($message !== '') {
            return response()->json(['status' => '<label>Insufficient Stock</label><br>', 'message' => $message], 200);
        }
        // $waybill = Waybill::where('invoice_id', $request->invoice_id)->first();
        // if (!$waybill) {
        $waybill = new Waybill();
        $waybill->warehouse_id = $warehouse_id;
        // $waybill->invoice_id = $request->invoice_id;
        $waybill->waybill_no = $request->waybill_no;
        $waybill->status = $request->status;
        $waybill->save();

        $waybill->invoices()->sync($invoice_ids);
        // create way bill items
        $waybill_item_obj = new WaybillItem();
        $waybill_item_obj->createWaybillItems($waybill->id, $warehouse_id, $invoice_items);

        // $invoice->status = 'waybill generated';
        // $invoice->save();

        $invoice_nos = [];
        foreach ($invoice_ids as $invoice_id) {
            $invoice = Invoice::find($invoice_id);
            $title = "Waybill Generated";
            $description = "Waybill ($waybill->waybill_no) generated for invoice ($invoice->invoice_number) by $user->name ($user->email)";
            //log this action to invoice history
            $this->createInvoiceHistory($invoice, $title, $description);

            //log this activity
            $this->logUserActivity($title, $description);
        }
        // }
        // $this->createDispatchedWaybill($waybill, $request);

        return response()->json(compact('waybill'), 200);
    }

    private function createDispatchedWaybill($waybill_id, $vehicle_id)
    {
        //
        $dispatched_waybill = DispatchedWaybill::where('waybill_id', $waybill_id)->first();
        if (!$dispatched_waybill) {
            $dispatched_waybill = new DispatchedWaybill();
        }
        $dispatched_waybill->waybill_id = $waybill_id;
        $dispatched_waybill->vehicle_id = $vehicle_id;
        $dispatched_waybill->save();
    }
    public function waybillExpenses(Request $request)
    {
        $warehouse_id = $request->warehouse_id;
        $trip_no = $this->nextReceiptNo('trip');
        $vehicles = Vehicle::with('vehicleDrivers.driver.user')->where('warehouse_id', $warehouse_id)->get();
        $delivery_trips = DeliveryTrip::with('cost', 'waybills', 'vehicle.vehicleDrivers.driver.user')->orderBy('id', 'DESC')->where(['warehouse_id' => $warehouse_id])->get();

        $waybills_with_pending_wayfare = Waybill::where(['warehouse_id' => $warehouse_id, 'waybill_wayfare_status' => 'pending'])->where('confirmed_by', '!=', null)->get();

        return response()->json(compact('delivery_trips', 'waybills_with_pending_wayfare', 'trip_no', 'vehicles'), 200);
    }

    public function addWaybillExpenses(Request $request)
    {
        $trip_no = $request->trip_no;
        $waybill_ids = $request->waybill_ids;
        $description = $request->description;
        $warehouse_id = $request->warehouse_id;
        $vehicle_id = $request->vehicle_id;
        $delivery_trip = new DeliveryTrip();
        $delivery_trip->warehouse_id = $warehouse_id;
        $delivery_trip->vehicle_id = $vehicle_id;
        $delivery_trip->trip_no = $trip_no;
        $delivery_trip->description = $description;
        if ($delivery_trip->save()) {
            //update next receipt no
            $this->incrementReceiptNo('trip');
            $delivery_trip->waybills()->syncWithoutDetaching($waybill_ids); // add all waybills for this trip
            foreach ($delivery_trip->waybills as $waybill) {
                // update waybill wayfare status
                $this->createDispatchedWaybill($waybill->id, $vehicle_id);
                $waybill->waybill_wayfare_status = 'given';
                $waybill->save();
            }
            // populate delivery trip expenses
            $delivery_trip_id = $delivery_trip->id;
            $delivery_expense = DeliveryTripExpense::where('delivery_trip_id', $delivery_trip_id)->first();
            if (!$delivery_expense) {
                $delivery_expense = new DeliveryTripExpense();
                $delivery_expense->warehouse_id = $warehouse_id;
                $delivery_expense->delivery_trip_id = $delivery_trip_id;
                $delivery_expense->amount = $request->amount;
                $delivery_expense->save();
            }
        }
        $user = $this->getUser();
        $title = "Created waybill delivery cost";
        $description = "New delivery cost for trip no.: " . $trip_no . " was created by $user->name ($user->email)";
        //log this activity
        $this->logUserActivity($title, $description);
        return $this->showDeliveryTrip($delivery_trip->id, $warehouse_id);
    }

    public function deliveryTripsForExtraCost(Request $request)
    {
        $regular_delivery_trips = DeliveryTripExpense::with('deliveryTrip')->where('expense_type', 'regular')->get();
        $extra_delivery_costs = DeliveryTripExpense::with(['confirmer', 'deliveryTrip.waybills', 'deliveryTrip.vehicle.vehicleDrivers.driver.user'])->where('expense_type', 'extra')->get();
        return response()->json(compact('regular_delivery_trips', 'extra_delivery_costs'), 200);
    }

    public function addExtraDeliveryCost(Request $request)
    {
        $delivery_trip_id = $request->delivery_trip_id;
        $delivery_trip = DeliveryTrip::find($delivery_trip_id);
        $delivery_expense = DeliveryTripExpense::where(['delivery_trip_id' => $delivery_trip_id, 'expense_type' => 'extra'])->first();
        if (!$delivery_expense) {
            $delivery_expense = new DeliveryTripExpense();
            $delivery_expense->warehouse_id = $delivery_trip->warehouse_id;
            $delivery_expense->delivery_trip_id = $request->delivery_trip_id;
            $delivery_expense->expense_type = 'extra';
            $delivery_expense->amount = $request->amount;
            $delivery_expense->details = $request->details;
            $delivery_expense->save();
        }
        $delivery_expense = DeliveryTripExpense::with(['confirmer', 'deliveryTrip.waybills', 'deliveryTrip.vehicle.vehicleDrivers.driver.user'])->where('expense_type', 'extra')->find($delivery_expense->id);
        return response()->json(compact('delivery_expense'), 200);
    }
    private function showDeliveryTrip($delivery_trip_id, $warehouse_id)
    {
        $trip_no = $this->nextReceiptNo('trip');
        $delivery_trip = DeliveryTrip::with('cost', 'waybills', 'vehicle.vehicleDrivers.driver.user')->orderBy('id', 'DESC')->find($delivery_trip_id);
        $waybills_with_pending_wayfare = Waybill::where(['warehouse_id' => $warehouse_id, 'waybill_wayfare_status' => 'pending'])->get();
        return response()->json(compact('delivery_trip', 'waybills_with_pending_wayfare', 'trip_no'), 200);
    }
    public function detachWaybillFromTrip(Request $request)
    {
        $waybill_id = $request->waybill_id;
        $delivery_trip_id = $request->delivery_trip_id;
        $delivery_trip = DeliveryTrip::find($delivery_trip_id);
        // if($delivery_trip->waybills()->count() == 1 ){
        //     // delete the delivery trip entry
        // }
        $delivery_trip->waybills()->detach($waybill_id);

        // update waybill wayfare status to pending
        $waybill = Waybill::find($waybill_id);
        $waybill->dispatcher()->delete();
        $waybill->waybill_wayfare_status = 'pending';
        $waybill->save();

        return $this->showDeliveryTrip($delivery_trip->id, $delivery_trip->warehouse_id);
    }
    public function changeWaybillStatus(Request $request, Waybill $waybill)
    {
        //
        $item_in_stock_obj = new ItemStockSubBatch();
        $invoice_item_obj = new InvoiceItem();
        $user = $this->getUser();
        $status = $request->status;
        // update waybill status
        $waybill->status = $status;
        $waybill->save();

        // update invoice items to account for partial supplies and complete ones
        $invoice_item_obj->updateInvoiceItemsForWaybill($waybill->waybillItems);
        // update items in stock based on waybill status
        if ($status === 'in transit') {
            $item_in_stock_obj->sendItemInStockForDelivery($waybill->waybillItems);
            // let's update the invoice items for this waybill
        }
        $invoices = $waybill->invoices;
        $title = "Waybill status updated";
        $description = "Waybill ($waybill->waybill_no) status updated to " . strtoupper($waybill->status) . " by $user->name ($user->email)";
        if ($status === 'delivered') {
            foreach ($invoices as  $invoice) {

                $item_in_stock_obj->confirmItemInStockAsSupplied($waybill->dispatchProducts);
                $invoice->status = $status;
                // check for partial supplies
                $incomplete_invoice_item = $invoice->invoiceItems()->where('supply_status', '=', 'Partial')->first();
                if ($incomplete_invoice_item) {
                    $invoice->status = 'partially supplied';
                }
                $invoice->save();
                //log this action to invoice history
                $this->createInvoiceHistory($invoice, $title, $description);
            }
        }


        //log this activity
        $this->logUserActivity($title, $description);
    }
    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \App\Models\Invoice\Invoice  $invoice
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, Invoice $invoice)
    {
        //
        $user = $this->getUser();
        $invoice_items = json_decode(json_encode($request->invoice_items));
        $invoice = Invoice::find($request->id);
        $invoice->subtotal            = $request->subtotal;
        $invoice->discount            = $request->discount;
        $invoice->amount              = $request->amount;
        $invoice->notes              = $request->notes;
        $invoice->save();
        $title = "Invoice modified";
        $description = "invoice ($invoice->invoice_number) was updated by $user->name ($user->email)";
        //log this action to invoice history
        $this->createInvoiceHistory($invoice, $title, $description);
        //create items invoiceed for
        $this->updateInvoiceItems($invoice_items);
        //////update next invoice number/////
        // $this->incrementInvoiceNo();

        //log this activity
        $this->logUserActivity($title, $description);
        return $this->show($invoice);
    }

    private function updateInvoiceItems($invoice_items)
    {
        foreach ($invoice_items as $item) {
            // $batches = $item->batches;
            $invoice_item = InvoiceItem::find($item->id);
            // keep the old quantity
            $old_quantity = $invoice_item->quantity;

            $invoice_item->quantity = $item->quantity;
            $invoice_item->no_of_cartons = $item->no_of_cartons;
            $invoice_item->type = $item->type;
            $invoice_item->rate = $item->rate;
            $invoice_item->amount = $item->amount;
            $invoice_item->save();

            $batches = $invoice_item->batches;
            $this->removeOldInvoiceItemBatchesAndCreateNewOne($invoice_item, $batches, $old_quantity);
        }
    }
    private function removeOldInvoiceItemBatchesAndCreateNewOne($invoice_item, $batches, $old_quantity)
    {
        $batch_ids = [];
        foreach ($batches as $invoice_item_batch) {
            $item_sub_batch = ItemStockSubBatch::find($invoice_item_batch->item_stock_sub_batch_id);
            // remove the old quantity reserved
            if ($item_sub_batch->reserved_for_supply >= $old_quantity) {
                $item_sub_batch->reserved_for_supply -= $old_quantity;
            } else {
                $item_sub_batch->reserved_for_supply = 0;
            }
            $item_sub_batch->save();
            $batch_ids[] = $invoice_item_batch->item_stock_sub_batch_id;
            // delete the old entry
            $invoice_item_batch->delete();
        }
        // create new one
        $this->createInvoiceItemBatches($invoice_item, $batch_ids);
    }
    /**
     * Remove the specified resource from storage.
     *
     * @param  \App\Models\Invoice\Invoice  $invoice
     * @return \Illuminate\Http\Response
     */
    public function destroy(Invoice $invoice)
    {
        //
        $actor = $this->getUser();
        $title = "Invoice deleted";
        $description = "Invoice ($invoice->invoice_number) was deleted by $actor->name ($actor->phone)";
        //log this activity
        $this->logUserActivity($title, $description);

        $invoice_items = $invoice->invoiceItems; //()->batches()->delete();
        foreach ($invoice_items as $invoice_item) {
            $invoice_item_batches = $invoice_item->batches;
            // we want to unreserve any product for this invoice
            foreach ($invoice_item_batches as $invoice_item_batch) {
                $quantity = $invoice_item_batch->quantity;
                $item_stock_sub_batch = ItemStockSubBatch::find($invoice_item_batch->item_stock_sub_batch_id);
                $item_stock_sub_batch->reserved_for_supply -= $quantity;
                $item_stock_sub_batch->save();

                // we then delete the invoice item batch
                $invoice_item_batch->delete();
            }
        }
        $invoice->invoiceItems()->delete();
        $invoice->delete();
        return response()->json(null, 204);
    }
}
